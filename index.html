<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Modelo interactivo + FluxSuite — solo CO₂ flux</title>
<style>
  html,body{margin:0;height:100%;background:#111;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial}
  #c{width:100%;height:100%;display:block}
  #tooltip{
    position:fixed;pointer-events:none;padding:.4rem .6rem;background:rgba(0,0,0,.75);
    border:1px solid rgba(255,255,255,.2);border-radius:6px;transform:translate(12px,12px);
    display:none;font-size:14px;white-space:nowrap;z-index:7
  }
  #hud{
    position:fixed;left:12px;top:12px;background:rgba(0,0,0,.55);padding:.6rem .8rem;border-radius:8px;
    border:1px solid rgba(255,255,255,.2);max-width:52ch;font-size:14px;line-height:1.15;z-index:5
  }
  #hud h3{margin:.2rem 0 .4rem;font-size:15px} #hud code{font-size:13px}
  #loading{
    position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.6);
    padding:.8rem 1rem;border:1px solid rgba(255,255,255,.2);border-radius:8px;z-index:10
  }
  /* —— Panel derecho con SOLO la gráfica de CO₂ flux —— */
  #right{
    position:fixed;right:0;top:0;bottom:0;width:min(420px,40vw);
    background:rgba(0,0,0,.55);border-left:1px solid rgba(255,255,255,.2);
    padding:.6rem .8rem;overflow:auto;z-index:6
  }
  #right h3{margin:.2rem 0 .4rem;font-size:15px}
  #right .panel{margin-bottom:12px}
  #right canvas{width:100%;height:280px}
  #right .legend-note{opacity:.7;font-size:12px;margin-top:4px}
</style>

<!-- Import map: resuelve 'three' y los addons -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
<!-- Chart.js para la ÚNICA gráfica de CO₂ flux -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
</head>
<body>
<canvas id="c"></canvas>
<div id="tooltip"></div>

<div id="hud">
  <h3>Datos (último valor por variable)</h3>
  <div id="station165">Torre 165: <code>—</code></div>
  <div id="station157">Torre 157: <code>—</code></div>
  <div style="margin-top:.35rem;opacity:.7;">Se actualiza cada ~10 min</div>
</div>

<!-- Panel derecho: SOLO CO₂ flux -->
<aside id="right" aria-label="Panel de gráficas">
  <div class="panel">
    <h3>CO₂ flux (últimos 8 días)</h3>
    <canvas id="co2Chart" aria-label="Gráfica de CO₂ flux"></canvas>
    <div class="legend-note">Series de las torres 165 y 157 superpuestas</div>
  </div>
</aside>

<div id="loading">Cargando modelo…</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";  // <— necesario para GLB con Draco

/* ========= CONFIG =========
   Publicado en GitHub Pages + Cloudflare Worker.
=========================== */
const PROXY_URL = "https://flux-proxy.daalbumu.workers.dev/series"; // tu Worker
const GLB_URL   = "./escena.glb";  // sube 'escena.glb' a la raíz del repo

/* --- Canvas + HUD refs --- */
const canvas  = document.getElementById('c');
const tooltip = document.getElementById('tooltip');
const loading = document.getElementById('loading');
const hud165  = document.getElementById('station165').querySelector('code');
const hud157  = document.getElementById('station157').querySelector('code');
const right   = document.getElementById('right');

/* --- Mapa canónico para tolerar renombres (Mesh_0.011 vs Mesh_0011) --- */
function canon(s){ return String(s||"").toLowerCase().replace(/[^\w]/g,""); }
const CANON_LABELS = Object.fromEntries(Object.entries(LABELS).map(([k,v]) => [canon(k), v]));

/* --- Three.js base --- */
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(50, 2, 0.1, 50000);
camera.position.set(8, 8, 12);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const hemi = new THREE.HemisphereLight(0xffffff, 0x303030, 0.9);
const dir  = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(20,30,20);
scene.add(hemi, dir);

/* --- Centrar/encuadrar el modelo --- */
function frameObject(object, camera, controls, padding = 1.2) {
  const box = new THREE.Box3().setFromObject(object);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  const maxSize = Math.max(size.x, size.y, size.z);
  const fitH = maxSize / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)));
  const fitW = fitH / camera.aspect;
  const distance = padding * Math.max(fitH, fitW);
  const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize().multiplyScalar(distance);
  controls.target.copy(center);
  camera.position.copy(center).add(dir);
  camera.near = distance / 100; camera.far = distance * 100;
  camera.updateProjectionMatrix(); controls.update();
}

/* --- Cargar GLB + Draco + animaciones + encuadre --- */
let mixers = [];

// DRACO loader (necesario para .glb comprimidos)
const draco = new DRACOLoader();
draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/");

const loader = new GLTFLoader();
loader.setDRACOLoader(draco);

loader.load(
  GLB_URL,
  (gltf)=>{
    loading.textContent = "Procesando escena…";
    scene.add(gltf.scene);

    if (gltf.animations && gltf.animations.length) {
      const mixer = new THREE.AnimationMixer(gltf.scene);
      gltf.animations.forEach(clip=>{
        const act = mixer.clipAction(clip);
        act.loop = THREE.LoopRepeat;
        act.play();
      });
      mixers.push(mixer);
    }

    frameObject(gltf.scene, camera, controls, 1.3);
    loading.style.display = "none";
  },
  (xhr)=>{
    const total = xhr.total || 0;
    loading.textContent = total ? `Cargando modelo… ${Math.round((xhr.loaded/total)*100)}%` : "Cargando modelo…";
  },
  (err)=>{
    console.error("Error GLB:", err);
    loading.textContent = "Error cargando el modelo. Revisa la consola (F12).";
  }
);

/* --- Tooltips on-hover --- */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2(-1,-1);
let overRight = false;

window.addEventListener('pointermove', e=>{
  const r = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - r.left) / r.width ) * 2 - 1;
  mouse.y = -((e.clientY - r.top ) / r.height) * 2 + 1;
  tooltip.style.left = `${e.clientX}px`;
  tooltip.style.top  = `${e.clientY}px`;
});
right.addEventListener('pointerenter', ()=>{ overRight=true; tooltip.style.display='none'; });
right.addEventListener('pointerleave', ()=>{ overRight=false; });

function getLabelFrom(object){
  // 1) etiqueta exportada desde Blender (Custom Properties -> userData.label)
  let o = object;
  while (o) {
    const ud = o.userData || {};
    if (ud.label && String(ud.label).trim() !== "") return String(ud.label);
    o = o.parent;
  }
  // 2) fallback tolerante a renombres
  const c = canon(object.name);
  return CANON_LABELS[c] || object.name;
}

function updateTooltip(){
  if (overRight) { tooltip.style.display='none'; return; }
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(scene.children, true);
  const hit = hits.find(h => h.object && h.object.isMesh);
  if (hit && hit.object) {
    tooltip.textContent = getLabelFrom(hit.object);
    tooltip.style.display = 'block';
  } else {
    tooltip.style.display = 'none';
  }
}

/* --- Loop de render --- */
function resize(){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  if (canvas.width !== w || canvas.height !== h) {
    renderer.setSize(w, h, false);
    camera.aspect = w/h; camera.updateProjectionMatrix();
  }
}
let last = performance.now();
function animate(now){
  const dt = (now - last)/1000; last = now;
  resize(); controls.update();
  mixers.forEach(m=>m.update(dt));
  updateTooltip();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* --- Datos (cada 10 min) --- */
const VARIABLES = ["H","LE","Rn_1_1_1","ch4_flux","co2_flux"]; // HUD conserva todas; gráficas: SOLO co2_flux
function lastPoint(list){ if(!Array.isArray(list)) return null;
  for(let i=list.length-1;i>=0;i--){const [ts,v]=list[i]; if(v!=null) return {ts,v};} return null; }
function tsToDate(ts){ return new Date(ts < 2e12 ? ts*1000 : ts); }
function serie(d,k){ return (d.series?.[k]?.[0]?.data) || []; }

async function fetchStation(stationId, windowDays=8){
  const nowS = Math.floor(Date.now()/1000), startS = nowS - windowDays*24*3600;
  const qs = new URLSearchParams({stationId:String(stationId), field:VARIABLES.join(","), startTime:String(startS), endTime:String(nowS)});
  const r = await fetch(`${PROXY_URL}?${qs}`, { cache:"no-store" });
  if(!r.ok) throw new Error("Proxy error "+r.status);
  return r.json();
}

async function refreshHUD(){
  try {
    const [d165, d157] = await Promise.all([ fetchStation(165), fetchStation(157) ]);
    const fmt = d => VARIABLES.map(k=>{
      const p = lastPoint(serie(d,k));
      return `${k}: ${p ? Number(p.v).toFixed(2) : 'N/A'}`;
    }).join(" · ");
    hud165.textContent = fmt(d165);
    hud157.textContent = fmt(d157);
  } catch(e){ console.error(e); }
}

/* === ÚNICA gráfica: CO₂ flux (165 vs 157) === */
let co2Chart = null;
function buildOrUpdateCO2Chart(d165, d157){
  const s165 = serie(d165,'co2_flux').filter(p=>p && p[1]!=null).map(([t,v])=>({x: tsToDate(t), y: v}));
  const s157 = serie(d157,'co2_flux').filter(p=>p && p[1]!=null).map(([t,v])=>({x: tsToDate(t), y: v}));
  const ctx = document.getElementById('co2Chart').getContext('2d');
  const data = {
    datasets: [
      { label:'CO₂ flux – 165', data:s165, parsing:false, spanGaps:true, pointRadius:0, borderWidth:1.5 },
      { label:'CO₂ flux – 157', data:s157, parsing:false, spanGaps:true, pointRadius:0, borderWidth:1.5 }
    ]
  };
  const options = {
    responsive:true, maintainAspectRatio:false,
    scales: {
      x: { type:'time', time:{ unit:'hour' }, ticks:{ maxTicksLimit:6 } },
      y: { title:{ display:true, text:'µmol m⁻² s⁻¹' }, ticks:{ autoSkip:true } }
    },
    plugins:{
      legend:{ position:'bottom' },
      tooltip:{ mode:'nearest', intersect:false, callbacks:{
        label:(ctx)=> `${ctx.dataset.label}: ${Number(ctx.parsed.y).toFixed(2)}`
      }}
    },
    elements:{ line:{ tension:0.2 } }
  };
  if (co2Chart) { co2Chart.data = data; co2Chart.update(); }
  else { co2Chart = new Chart(ctx, { type:'line', data, options }); }
}

async function refreshCO2(){
  try{
    const [d165, d157] = await Promise.all([ fetchStation(165), fetchStation(157) ]);
    buildOrUpdateCO2Chart(d165, d157);
  }catch(e){ console.error(e); }
}

// Primera carga + cada 10 min
refreshHUD();
refreshCO2();
setInterval(()=>{ refreshHUD(); refreshCO2(); }, 600_000);
</script>
</body>
</html>
