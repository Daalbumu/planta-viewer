<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Modelo interactivo + FluxSuite</title>
<style>
  html,body{margin:0;height:100%;background:#111;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial}
  #c{width:100%;height:100%;display:block}
  #tooltip{
    position:fixed;pointer-events:none;padding:.4rem .6rem;background:rgba(0,0,0,.75);
    border:1px solid rgba(255,255,255,.2);border-radius:6px;transform:translate(12px,12px);
    display:none;font-size:14px;white-space:nowrap
  }
  #hud{
    position:fixed;left:12px;top:12px;background:rgba(0,0,0,.55);padding:.6rem .8rem;border-radius:8px;
    border:1px solid rgba(255,255,255,.2);max-width:52ch;font-size:14px;line-height:1.15;z-index:5
  }
  #hud h3{margin:.2rem 0 .4rem;font-size:15px} #hud code{font-size:13px}
  #loading{
    position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.6);
    padding:.8rem 1rem;border:1px solid rgba(255,255,255,.2);border-radius:8px;z-index:10
  }

  /* ====== (AGREGADO) Panel de gráfica CO₂ 157 a la derecha ====== */
  #charts{
    position:fixed;right:12px;top:12px;width:520px;max-height:calc(100% - 24px);
    background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.2);border-radius:8px;
    padding:.6rem .8rem;overflow:auto;z-index:6
  }
  #charts h3{margin:.2rem 0 .4rem;font-size:15px}
  #charts .row{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
  #charts label{font-size:12px;opacity:.85}
  #charts input,#charts select{
    background:#1b1b1b;color:#fff;border:1px solid rgba(255,255,255,.2);
    padding:.25rem .4rem;border-radius:6px;font-size:12px
  }
  #charts button{
    cursor:pointer;background:#2a2a2a;color:#fff;border:1px solid rgba(255,255,255,.2);
    padding:.35rem .6rem;border-radius:6px;font-size:12px
  }
  #chart_CO2_157{
    background:rgba(255,255,255,.04);border-radius:6px;margin-top:.5rem; height:320px;
  }
</style>

<!-- Import map: resuelve 'three' y los addons -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<!-- (AGREGADO) Chart.js para la gráfica -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
</head>
<body>
<canvas id="c"></canvas>
<div id="tooltip"></div>

<div id="hud">
  <h3>Datos (último valor por variable)</h3>
  <div id="station165">Torre 165: <code>—</code></div>
  <div id="station157">Torre 157: <code>—</code></div>
  <div style="margin-top:.35rem;opacity:.7;">Se actualiza cada ~10 min</div>
</div>

<!-- (AGREGADO) Panel de gráfica de CO₂ — Torre 157 -->
<div id="charts">
  <div class="row" style="margin-bottom:.4rem;">
    <h3 style="flex:1">CO₂ flux — Torre 157</h3>
  </div>
  <div class="row">
    <label>Desde:&nbsp;<input type="datetime-local" id="dtFrom"></label>
    <label>Hasta:&nbsp;<input type="datetime-local" id="dtTo"></label>
    <button id="btnApply">Aplicar rango</button>
    <span style="flex:1"></span>
    <label>Últimos&nbsp;
      <select id="selDays">
        <option value="3">3d</option>
        <option value="7">7d</option>
        <option value="10" selected>10d</option>
        <option value="14">14d</option>
        <option value="30">30d</option>
      </select>
    </label>
    <button id="btnLast">Usar últimos N días</button>
  </div>
  <canvas id="chart_CO2_157"></canvas>
</div>

<div id="loading">Cargando modelo…</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";  // <— necesario para GLB con Draco

/* ========= CONFIG =========
   Publicado en GitHub Pages + Cloudflare Worker.
=========================== */
const PROXY_URL = "https://flux-proxy.daalbumu.workers.dev/series"; // tu Worker
const GLB_URL   = "./escena.glb";  // sube 'escena.glb' a la raíz del repo

/* --- Canvas + HUD refs --- */
const canvas  = document.getElementById('c');
const tooltip = document.getElementById('tooltip');
const loading = document.getElementById('loading');
const hud165  = document.getElementById('station165').querySelector('code');
const hud157  = document.getElementById('station157').querySelector('code');

/* --- Etiquetas base (del proyecto) --- */
const LABELS = {
  "Mesh_0.011": "Machín petrolero",
  "Mesh_0.002": "1 Cámaras automatizadas LI-COR 8200",
  "Mesh_0.003": "2 Cámaras automatizadas LI-COR 8200",
  "Mesh_0.004": "3 Cámaras automatizadas LI-COR 8200",
  "Mesh_0.005": "4 Cámaras automatizadas LI-COR 8200",
  "Mesh_0.018": "1 PALAS",
  "Mesh_0.059": "2 PALAS",
  "Mesh_0.001": "torre eddy covarience sur",
  "Mesh_0.008": "torre eddy covarience norte",
  "Mesh_0.034": "Llanito 114"
};

/* --- Mapa canónico para tolerar renombres (Mesh_0.011 vs Mesh_0011) --- */
function canon(s){ return String(s||"").toLowerCase().replace(/[^\w]/g,""); }
const CANON_LABELS = Object.fromEntries(Object.entries(LABELS).map(([k,v]) => [canon(k), v]));

/* --- Three.js base --- */
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(50, 2, 0.1, 50000);
camera.position.set(8, 8, 12);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const hemi = new THREE.HemisphereLight(0xffffff, 0x303030, 0.9);
const dir  = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(20,30,20);
scene.add(hemi, dir);

/* --- Centrar/encuadrar el modelo --- */
function frameObject(object, camera, controls, padding = 1.2) {
  const box = new THREE.Box3().setFromObject(object);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  const maxSize = Math.max(size.x, size.y, size.z);
  const fitH = maxSize / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)));
  const fitW = fitH / camera.aspect;
  const distance = padding * Math.max(fitH, fitW);
  const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize().multiplyScalar(distance);
  controls.target.copy(center);
  camera.position.copy(center).add(dir);
  camera.near = distance / 100; camera.far = distance * 100;
  camera.updateProjectionMatrix(); controls.update();
}

/* --- Cargar GLB + Draco + animaciones + encuadre --- */
let mixers = [];

// DRACO loader (necesario para .glb comprimidos)
const draco = new DRACOLoader();
draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/");

const loader = new GLTFLoader();
loader.setDRACOLoader(draco);

loader.load(
  GLB_URL,
  (gltf)=>{
    loading.textContent = "Procesando escena…";
    scene.add(gltf.scene);

    if (gltf.animations && gltf.animations.length) {
      const mixer = new THREE.AnimationMixer(gltf.scene);
      gltf.animations.forEach(clip=>{
        const act = mixer.clipAction(clip);
        act.loop = THREE.LoopRepeat;
        act.play();
      });
      mixers.push(mixer);
    }

    frameObject(gltf.scene, camera, controls, 1.3);
    loading.style.display = "none";
  },
  (xhr)=>{
    const total = xhr.total || 0;
    loading.textContent = total ? `Cargando modelo… ${Math.round((xhr.loaded/total)*100)}%` : "Cargando modelo…";
  },
  (err)=>{
    console.error("Error GLB:", err);
    loading.textContent = "Error cargando el modelo. Revisa la consola (F12).";
  }
);

/* --- Tooltips on-hover --- */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2(-1,-1);

window.addEventListener('pointermove', e=>{
  const r = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - r.left) / r.width ) * 2 - 1;
  mouse.y = -((e.clientY - r.top ) / r.height) * 2 + 1;
  tooltip.style.left = `${e.clientX}px`;
  tooltip.style.top  = `${e.clientY}px`;
});

function getLabelFrom(object){
  // 1) etiqueta exportada desde Blender (Custom Properties -> userData.label)
  let o = object;
  while (o) {
    const ud = o.userData || {};
    if (ud.label && String(ud.label).trim() !== "") return String(ud.label);
    o = o.parent;
  }
  // 2) fallback tolerante a renombres
  const c = canon(object.name);
  return CANON_LABELS[c] || object.name;
}

function updateTooltip(){
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(scene.children, true);
  const hit = hits.find(h => h.object && h.object.isMesh);
  if (hit && hit.object) {
    tooltip.textContent = getLabelFrom(hit.object);
    tooltip.style.display = 'block';
  } else {
    tooltip.style.display = 'none';
  }
}

/* --- Loop de render --- */
function resize(){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  if (canvas.width !== w || canvas.height !== h) {
    renderer.setSize(w, h, false);
    camera.aspect = w/h; camera.updateProjectionMatrix();
  }
}
let last = performance.now();
function animate(now){
  const dt = (now - last)/1000; last = now;
  resize(); controls.update();
  mixers.forEach(m=>m.update(dt));
  updateTooltip();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* --- Datos (cada 10 min) --- */
const VARIABLES = ["H","LE","Rn_1_1_1","ch4_flux","co2_flux"];
function lastPoint(list){ if(!Array.isArray(list)) return null;
  for(let i=list.length-1;i>=0;i--){const [ts,v]=list[i]; if(v!=null) return {ts,v};} return null; }
async function fetchStation(stationId, windowDays=8){
  const nowS = Math.floor(Date.now()/1000), startS = nowS - windowDays*24*3600;
  const qs = new URLSearchParams({stationId:String(stationId), field:VARIABLES.join(","), startTime:String(startS), endTime:String(nowS)});
  const r = await fetch(`${PROXY_URL}?${qs}`, { cache:"no-store" });
  if(!r.ok) throw new Error("Proxy error "+r.status);
  return r.json();
}
async function refreshData(){
  try {
    const [d165, d157] = await Promise.all([ fetchStation(165), fetchStation(157) ]);
    const fmt = d => VARIABLES.map(k=>{
      const serie = (d.series?.[k]?.[0]?.data) || [];
      const p = lastPoint(serie);
      return `${k}: ${p ? Number(p.v).toFixed(2) : 'N/A'}`;
    }).join(" · ");
    hud165.textContent = fmt(d165);
    hud157.textContent = fmt(d157);
  } catch(e){ console.error(e); }
}
refreshData(); setInterval(refreshData, 600_000); // 10 min

/* ========== (AGREGADO) Gráfica CO₂ — Torre 157 ========== */
const dtFrom = document.getElementById('dtFrom');
const dtTo   = document.getElementById('dtTo');
const btnApply = document.getElementById('btnApply');
const btnLast  = document.getElementById('btnLast');
const selDays  = document.getElementById('selDays');
let co2Chart;

const toEpochS = (dtLocal)=> Math.floor(new Date(dtLocal).getTime()/1000);
const fmtTs = (ms)=> new Date(ms).toLocaleString([], {hour12:false, month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit'});

function upsertCO2157(labels, values){
  const ctx = document.getElementById('chart_CO2_157');
  if(co2Chart){ co2Chart.data.labels = labels; co2Chart.data.datasets[0].data = values; co2Chart.update(); return; }
  co2Chart = new Chart(ctx, {
    type:'line',
    data:{ labels, datasets:[{ label:'co2_flux (µmol/m²s) — 157', data:values, fill:false, tension:0.2, pointRadius:0, borderWidth:2 }] },
    options:{ animation:false, responsive:true, maintainAspectRatio:false,
      plugins:{ legend:{display:false}, tooltip:{mode:'index', intersect:false} },
      scales:{ x:{ ticks:{ color:'#ddd', maxTicksLimit:6 }, grid:{ color:'rgba(255,255,255,.08)' } },
              y:{ ticks:{ color:'#ddd' }, grid:{ color:'rgba(255,255,255,.08)' }, title:{display:true,text:'µmol m⁻² s⁻¹'} } }
    }
  });
}

async function fetchCO2157(startS, endS){
  const qs = new URLSearchParams({
    stationId:'157', field:'co2_flux', startTime:String(startS), endTime:String(endS), format:'highcharts'
  });
  const r = await fetch(`${PROXY_URL}?${qs}`, { cache:'no-store' });
  if(!r.ok) throw new Error('Proxy error '+r.status);
  const data = await r.json();
  const serie = data?.series?.co2_flux?.[0]?.data || [];
  const labels=[], values=[];
  for(const [ts,v] of serie){ if(v==null) continue; labels.push(fmtTs(ts)); values.push(v); }
  return {labels, values};
}

async function drawCO2157(startS, endS){
  try{ const s = await fetchCO2157(startS,endS); upsertCO2157(s.labels, s.values); }
  catch(e){ console.error('CO2 chart error:', e); }
}

// Defaults: últimos 10 días
(function setDefaults(){
  const now = new Date();
  const from = new Date(now.getTime() - 10*24*3600*1000);
  const toLocal = (d)=> {
    const pad = n => String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
  };
  if(dtFrom) dtFrom.value = toLocal(from);
  if(dtTo)   dtTo.value   = toLocal(now);
})();

// Eventos
if(btnApply) btnApply.addEventListener('click', ()=>{
  if(!dtFrom.value || !dtTo.value) return;
  const startS = toEpochS(dtFrom.value), endS = toEpochS(dtTo.value);
  drawCO2157(startS, endS);
});
if(btnLast) btnLast.addEventListener('click', ()=>{
  const days = Number(selDays?.value||10);
  const endS = Math.floor(Date.now()/1000);
  const startS = endS - days*24*3600;
  drawCO2157(startS, endS);
});
// Pintar inicial
(function initialCO2(){
  const endS = Math.floor(Date.now()/1000);
  const startS = endS - 10*24*3600;
  drawCO2157(startS, endS);
})();
</script>
</body>
</html>
